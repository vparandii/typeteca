# API Reference

- [Types](#types)
  - [`Email`](#email)
  - [`Password`](#password)
  - [`Uri`](#uri)
  - [`BcryptHash`](#bcrypthash)
- [Inheritance](#inharitance)
  - [`CustomString`](#CustomString)
- [Errors](#errors)
  - [`ValidationError`](#validationerror)

## Types

You can import types through the core `typeteca` object:
```js
const {Email} = require('typeteca')
```
...or import each one separately:
```js
const Email = require('typeteca/types/email')
```

### `Email`

```js
class Email extends CustomString {/* magic */}

const email = new Email('username@example.com')

console.log(email)          
// [String: 'username@example.com']
```

Value rules:
* is valid String type
* has valid email format
* satisfies pattern `/^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/`

### `Password`

```js
class Password extends CustomString {/* magic */}

const password = new Password('secret')

console.log(password)          
// [String: 'secret']
```

Value rules:
* is valid String type
* might use any characters
* has 6-30 characters length
* satisfies pattern `/^.{6,30}$/`

### `Uri`

```js
class Uri extends CustomString {/* magic */}

const uri = new Uri('https://example.com/about?lang=en')

console.log(uri)
// [String: 'https://example.com/about?lang=en']
```

Value rules:
* is valid String type
* has valid uri format
* starts with `http://`, `https://` or `www.`
* satisfies pattern `/^((https:|http:|[\/][\/]|www.)([a-z]|[A-Z]|[:0-9]|[\/.])*)$/`

### `BcryptHash`

```js
class BcryptHash extends CustomString {/* magic */}

const salt = bcrypt.genSaltSync(10)
const password_hash = bcrypt.hashSync('password', salt)

const hash = new BcryptHash(password_hash)

console.log(hash)
// [String: '$2a$10$KMsZaedzdV0QbfLUFbPAk..b2si0b71K.X2QkmQ.NlINbYVh2THbu']
```

Value rules:
* is valid String type
* is generated by [`bcrypt`](https://github.com/kelektiv/node.bcrypt.js) lib
* has 60 characters length
* satisfies pattern `/^[.\/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$]{60}$/`

## Inheritance

Each Typeteca Type primarily extends one of included util class, that in its turn inherits corresponding built-in JavaScript type: String, Number, etc.

Util classes brings additional validation layer into inherited type class as well as involves it's custom rules during value initiation.

All Typeteca Types keep the following requirements: extends one of `CustomType` util class, has method `validate(value)` and `throw` message if any internal rules/checks/validations were violated.

```js
const typeteca = require('typeteca')

const {CustomString} = typeteca
// or
const CustomString = require('typeteca/utils/custom-string')

class Email extends CustomString {
  validate(value){
    if (!/^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/.test(value))
      throw 'Incorrect value format: expected valid email format'
  }
}

typeteca.Email = Email

module.exports = Email
```

You are free to use the following util classes in order to build your own Types, or eventually help us to extend Typeteca library :blush:

**Note:** Including new types into `typeteca` registry is optionally and not required for your internal use.

### `CustomString`

```js
class CustomString extends String {/* magic */}

class NewAwesomeType extends CustomString {
  validate(value){
    if (value === 'awesome bad value')
      throw 'awesome error message'
  }
}

const awesome = new NewAwesomeType('valid value')
// [String: 'valid value']
const awesome = new NewAwesomeType()
// [String: '']
const awesome = new NewAwesomeType('awesome bad value')
// ValidationError: awesome error message
const awesome = new NewAwesomeType(48)
// ValidationError: Incorrect value type - NewAwesomeType: expected valid String type

typeteca.NewAwesomeType = NewAwesomeType

module.exports = NewAwesomeType
```
This util class shares the following value rules:
* is valid String type
* might be `null` or `undefined`

## Errors

Internally each Typeteca util class uses custom error objects to keep unified error handling flow. You might perform checks at your project's code level if caught error is `instanceof` any declared error.

Each custom error has it's own appearance context, meaning and can be used externally to share the same error handling flow.

### `ValidationError`

```js
const {ValidationError} = require('typeteca')
// or
const ValidationError = require('typeteca/utils/validation-error')

try {
  const email = new Email(value)
  // applying custom validation checks might throw errors as well:
  if (email == 'some value') throw new ValidationError('forbidden email')
} catch (error) {
  if (error instanceof ValidationError) {/*...*/}
}
```
